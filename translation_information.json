{
    "instructions":[
        {
            "name": "loadv",
            "param": ["variable","offset","depth"],
            "template": [
                "mov %eax,eax_saving",
                "movl <variable>_if<depth>+<offset>,%eax",
                "mov %eax,<variable>",
                "mov eax_saving,%eax"
            ]
        },
        {
            "name": "storev",
            "param": ["variable","offset","depth"],
            "template": [
                "mov %eax,eax_saving",
                "movl <variable>,%eax",
                "mov %eax, <variable>_if<depth>+<offset>",
                "mov eax_saving,%eax"
            ]
        },
        {
            "name": "loadr",
            "param": ["register","offset","depth"],
            "except":[["register%","%/register"]],
            "template": [
                "mov <register%>_if<depth>+<offset>,<register>"
            ]
        },
        {
            "name": "storer",
            "param": ["register","offset","depth"],
            "except":[["register%","%/register"]],
            "template": [
                "mov <register>,<register%>_if<depth>+<offset>"
            ]
        },
        {
            "name": "updater",
            "param": ["register","depth"],
            "except":[["register%","%/register"]],
            "template": [
                "mov <register%>_if<depth>(,%ebx,1),<register>"
            ]
        },
        {
            "name": "updatev",
            "param": ["variable","depth"],
            "template": [
                "mov %eax,eax_saving",
                "mov <variable>_if<depth>(,%ebx,1),%eax",
                "mov %eax,<variable>",
                "mov eax_saving,%eax"
            ]
        },
        {
            "name": "updatel",
            "param": ["variable","depth","index","length"],
            "except": [""],
            "template": [
                "mov %eax,eax_saving",
                "mov <variable>_if<depth>(,%ebx,<length>),%eax",
                "mov %eax,<variable>",
                "mov eax_saving,%eax"
            ]
        },
        {
            "name": "loadl",
            "param": ["vector","offset","depth","index","length"],
            "except": [["offsetg","ofv/offset/length/index"]],
            "template": [
                "mov %eax,eax_saving",
                "mov <vector>_if<depth>+<offsetg>,%eax",
                "mov %eax,<vector>+<index>",
                "mov eax_saving,%eax"
            ]
        },
        {
            "name": "storel",
            "param": ["vector","offset","depth","index","length"],
            "except": [["offsetg","ofv/offset/length/index"]],
            "template": [
                "mov %eax,eax_saving",
                "mov <vector>+<index>,%eax",
                "mov %eax,<vector>_if<depth>+<offsetg>",
                "mov eax_saving,%eax"
            ]
        },
        {
            "name": "lea",
            "param": ["memory_place","destination"],
            "template": [
                "mov $<memory_place>,<destination>"
            ]
        },
        {
            "name": "load_operand_x_r",
            "param": ["register"],
            "template": [
                "mov <register>,if_operand_x"
            ]
        },
        {
            "name": "load_operand_y_r",
            "param": ["register"],
            "template": [
                "mov <register>,if_operand_y"
            ]
        },
        {
            "name": "load_operand_x_v",
            "param": ["variable"],
            "template": [
                "mov <variable>, %ebp",
                "mov %ebp,if_operand_x"
            ]
        },
        {
            "name": "load_operand_y_v",
            "param": ["variable"],
            "template": [
                "mov <variable>, %ebp",
                "mov %ebp,if_operand_y"
            ]
        },
                {
            "name": "load_operand_x_i",
            "param": ["imm"],
            "template": [
                "mov <imm>,if_operand_x"
            ]
        },
        {
            "name": "load_operand_y_i",
            "param": ["imm"],
            "template": [
                "mov <imm>,if_operand_y"
            ]
        },
        {
            "name": "cmp",
            "param": [],
            "template": [
                ""
            ]
        },
        {
            "name": "cmpl",
            "param": [],
            "template": [
                ""
            ]
        },
        {
            "name": "cmp_eq",
            "param": ["depth"],
            "template":[
                "mov $0,%eax",
                "movb if_operand_x,%al",
                "movb $0,eq(,%eax,1)",
                "movb if_operand_y,%al",
                "movb $4,eq(,%eax,1)",
                "movb if_operand_x,%al",
                "mov $0,%ebx",
                "movb eq(,%eax,1),%bl",
                "mov %ebx,selector_if<depth>"
            ]
        },
        {
            "name": "cmp_ne",
            "param": ["depth"],
            "template":[
                "mov $0,%eax",
                "movb if_operand_x,%al",
                "movb $4,eq(,%eax,1)",
                "movb if_operand_y,%al",
                "movb $0,eq(,%eax,1)",
                "movb if_operand_x,%al",
                "mov $0,%ebx",
                "movb eq(,%eax,1),%bl",
                "mov %ebx,selector_if<depth>"
            ]
        },
                {
            "name": "cmp_g",
            "param": ["depth"],
            "template": [
                "movl %eax, temp_eax",
                "movl %ebx, temp_ebx",
                "movl %ecx, temp_ecx",
                "movl %edx, temp_edx",
                "movzbl if_operand_y, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_src_buf",
                "movzbl if_operand_y+1, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_src_buf+1",
                "movzbl if_operand_y+2, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_src_buf+2",
                "movzbl if_operand_y+3, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_src_buf+3",
                "movb $1, current_carry",
                "movzbl if_operand_x, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl temp_res, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl if_operand_x+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+1",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl if_operand_x+2, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+2",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl if_operand_x+3, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+3, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+3",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl temp_res, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_res+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_res+2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_res+3, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movb NON_ZERO_LUT(%ecx), %al",
                "movzbl %al, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %eax",
                "movl VAL_TO_OFFSET_LUT(,%eax, 4), %ebx",
                "movl %ebx, selector_if<depth>",
                "movl temp_edx, %edx",
                "movl temp_ecx, %ecx",
                "movl temp_ebx, %ebx",
                "movl temp_eax, %eax"
            ]
        },

        {
            "name": "cmp_b",
            "param": ["depth"],
            "template": [
                "movl %eax, temp_eax",
                "movl %ebx, temp_ebx",
                "movl %ecx, temp_ecx",
                "movl %edx, temp_edx",
                "movzbl if_operand_y, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_src_buf",
                "movzbl if_operand_y+1, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_src_buf+1",
                "movzbl if_operand_y+2, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_src_buf+2",
                "movzbl if_operand_y+3, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_src_buf+3",
                "movb $1, current_carry",
                "movzbl if_operand_x, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl temp_res, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl if_operand_x+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+1",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl if_operand_x+2, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+2",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl if_operand_x+3, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+3, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+3",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl current_carry, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movzbl %al, %ecx",
                "movzbl IS_ZERO_LUT(%ecx), %al",
                "movzbl %al, %eax",
                "movl VAL_TO_OFFSET_LUT(,%eax, 4), %ebx",
                "movl %ebx, selector_if<depth>",
                "movl temp_edx, %edx",
                "movl temp_ecx, %ecx",
                "movl temp_ebx, %ebx",
                "movl temp_eax, %eax"
            ]
        },

        {
            "name": "cmp_be",
            "param": ["depth"],
            "template": [
                "movl %eax, temp_eax",
                "movl %ebx, temp_ebx",
                "movl %ecx, temp_ecx",
                "movl %edx, temp_edx",
                "movzbl if_operand_y, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_src_buf",
                "movzbl if_operand_y+1, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_src_buf+1",
                "movzbl if_operand_y+2, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_src_buf+2",
                "movzbl if_operand_y+3, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_src_buf+3",
                "movb $1, current_carry",
                "movzbl if_operand_x, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl temp_res, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl if_operand_x+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+1",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl if_operand_x+2, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+2",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl if_operand_x+3, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+3, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+3",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl temp_res, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_res+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_res+2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_res+3, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movb IS_ZERO_LUT(%ecx), %al",
                "movb %al, temp_c1",
                "movzbl current_carry, %ecx",
                "movb IS_ZERO_LUT(%ecx), %al",
                "movzbl %al, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %eax",
                "movl VAL_TO_OFFSET_LUT(,%eax, 4), %ebx",
                "movl %ebx, selector_if<depth>",
                "movl temp_edx, %edx",
                "movl temp_ecx, %ecx",
                "movl temp_ebx, %ebx",
                "movl temp_eax, %eax"
            ]
        }, 

        {
            "name": "cmp_a",
            "param": ["depth"],
            "template": [
                "movl %eax, temp_eax",
                "movl %ebx, temp_ebx",
                "movl %ecx, temp_ecx",
                "movl %edx, temp_edx",
                "movzbl if_operand_y, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_src_buf",
                "movzbl if_operand_y+1, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_src_buf+1",
                "movzbl if_operand_y+2, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_src_buf+2",
                "movzbl if_operand_y+3, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_src_buf+3",
                "movb $1, current_carry",
                "movzbl if_operand_x, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl temp_res, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl if_operand_x+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+1",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl if_operand_x+2, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+2",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl if_operand_x+3, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+3, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+3",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl temp_res, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_res+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_res+2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_res+3, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movb NON_ZERO_LUT(%ecx), %al",
                "movzbl %al, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %eax",
                "movl VAL_TO_OFFSET_LUT(,%eax, 4), %ebx",
                "movl %ebx, selector_if<depth>",
                "movl temp_edx, %edx",
                "movl temp_ecx, %ecx",
                "movl temp_ebx, %ebx",
                "movl temp_eax, %eax"
            ]
        }, 

        {
            "name": "cmp_ae",
            "param": ["depth"],
            "template": [
                "movl %eax, temp_eax",
                "movl %ebx, temp_ebx",
                "movl %ecx, temp_ecx",
                "movl %edx, temp_edx",
                "movzbl if_operand_y, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_src_buf",
                "movzbl if_operand_y+1, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_src_buf+1",
                "movzbl if_operand_y+2, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_src_buf+2",
                "movzbl if_operand_y+3, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_src_buf+3",
                "movb $1, current_carry",
                "movzbl if_operand_x, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl temp_res, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl if_operand_x+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+1",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl if_operand_x+2, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+2",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl if_operand_x+3, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+3, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+3",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl current_carry, %eax",
                "movl VAL_TO_OFFSET_LUT(,%eax, 4), %ebx",
                "movl %ebx, selector_if<depth>",
                "movl temp_edx, %edx",
                "movl temp_ecx, %ecx",
                "movl temp_ebx, %ebx",
                "movl temp_eax, %eax"
            ]
        }, 
        {
            "name": "prepare_selector",
            "param": ["depth"],
            "template":[
                "mov selector_if<depth>,%ebx"
            ]
        },
        {
            "name": "syscall",
            "param": ["flag"],
            "template":[
                "cmp $1,<flag>",
                "je syscall_section",
                "return_syscall:"
            ]
        },
        {
            "name": "fcall",
            "param": ["flag","function"],
            "template":[
                "cmp $1,<flag>",
                "je <function>call_section",
                "return_<function>call:"
            ]
        },
        {
            "name": "inc",
            "param": ["register"],
            "except": [["register_low","l/register"]],
            "template":[
                "movzbl <register_low>, <register>",
                "movb inc_table(<register>), <register_low>"
            ]
        },
        {
            "name": "inc",
            "param": ["register"],
            "except": [["register_low","l/register"]],
            "template":[
                "movzbl <register_low>, <register>",
                "movb inc_table(<register>), <register_low>"
            ]
        },
        {
            "name": "dec",
            "param": ["register"],
            "except": [["register_low","l/register"]],
            "template":[
                "movzbl <register_low>, <register>",
                "movb inc_table(<register>), <register_low>"
            ]
        },
                {
            "name": "push",
            "param": ["register"],
            "except": [["register_low","l/register"]],
            "template":[
                "movzbl <register_low>, <register>",
                "movb inc_table(<register>), <register_low>"
            ]
        },
        {
            "name": "pop",
            "param": ["vector","index","offset","depth"],
            "except": [["register_low","l/register"]],
            "template":[
                "wip"
            ]
        },
                {
            "name": "incl",
            "param": ["register"],
            "except": [["register_low","l/register"]],
            "template":[
                "movzbl <register_low>, <register>",
                "movb inc_table(<register>), <register_low>"
            ]
        },
        {
            "name": "decl",
            "param": ["register"],
            "except": [["register_low","l/register"]],
            "template":[
                "movzbl <register_low>, <register>",
                "movb inc_table(<register>), <register_low>"
            ]
        },
                {
            "name": "pushl",
            "param": ["register"],
            "except": [["register_low","l/register"]],
            "template":[
                "movzbl <register_low>, <register>",
                "movb inc_table(<register>), <register_low>"
            ]
        },
        {
            "name": "popl",
            "param": ["vector","index","offset","depth"],
            "except": [["register_low","l/register"]],
            "template":[
                "wip"
            ]
        },
        {
            "name": "and",
            "param": ["src", "dest"],
            "template": [
                "### Save Context ###",
                "movl %eax, temp_eax",
                "movl %ebx, temp_ebx",
                "movl %ecx, temp_ecx",
                "movl %edx, temp_edx",

                "### Load Operands into Buffers ###",
                "movl <dest>, temp_dest_buf",
                "movl <src>, temp_src_buf",

                "### Byte 0 (Lowest) ###",
                "movzbl temp_dest_buf, %ecx",
                "movl AND_PTRS(,%ecx, 4), %edx",
                "movzbl temp_src_buf, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res",

                "### Byte 1 ###",
                "movzbl temp_dest_buf+1, %ecx",
                "movl AND_PTRS(,%ecx, 4), %edx",
                "movzbl temp_src_buf+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+1",

                "### Byte 2 ###",
                "movzbl temp_dest_buf+2, %ecx",
                "movl AND_PTRS(,%ecx, 4), %edx",
                "movzbl temp_src_buf+2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+2",

                "### Byte 3 (Highest) ###",
                "movzbl temp_dest_buf+3, %ecx",
                "movl AND_PTRS(,%ecx, 4), %edx",
                "movzbl temp_src_buf+3, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+3",

                "### Finalize: Move result back and Restore ###",
                "movl temp_eax, %eax",
                "movl temp_ebx, %ebx",
                "movl temp_ecx, %ecx",
                "movl temp_edx, %edx",
                "movl temp_res, <dest>"
            ]
        },
        {
            "name": "andl",
            "param": ["src", "dest"],
            "template": [
                "### Save Context ###",
                "movl %eax, temp_eax",
                "movl %ebx, temp_ebx",
                "movl %ecx, temp_ecx",
                "movl %edx, temp_edx",

                "### Load Operands into Buffers ###",
                "movl <dest>, temp_dest_buf",
                "movl <src>, temp_src_buf",

                "### Byte 0 (Lowest) ###",
                "movzbl temp_dest_buf, %ecx",
                "movl AND_PTRS(,%ecx, 4), %edx",
                "movzbl temp_src_buf, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res",

                "### Byte 1 ###",
                "movzbl temp_dest_buf+1, %ecx",
                "movl AND_PTRS(,%ecx, 4), %edx",
                "movzbl temp_src_buf+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+1",

                "### Byte 2 ###",
                "movzbl temp_dest_buf+2, %ecx",
                "movl AND_PTRS(,%ecx, 4), %edx",
                "movzbl temp_src_buf+2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+2",

                "### Byte 3 (Highest) ###",
                "movzbl temp_dest_buf+3, %ecx",
                "movl AND_PTRS(,%ecx, 4), %edx",
                "movzbl temp_src_buf+3, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+3",

                "### Finalize: Move result back and Restore ###",
                "movl temp_eax, %eax",
                "movl temp_ebx, %ebx",
                "movl temp_ecx, %ecx",
                "movl temp_edx, %edx",
                "movl temp_res, <dest>"
            ]
        },
        {
            "name": "or",
            "param": ["src", "dest"],
            "template": [
                "movl %eax, temp_eax",
                "movl %ebx, temp_ebx",
                "movl %ecx, temp_ecx",
                "movl %edx, temp_edx",

                "movl <dest>, temp_dest_buf",
                "movl <src>, temp_src_buf",

                "### Procesare Byte 0 ###",
                "movzbl temp_dest_buf, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res",

                "### Procesare Byte 1 ###",
                "movzbl temp_dest_buf+1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+1",

                "### Procesare Byte 2 ###",
                "movzbl temp_dest_buf+2, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+2",

                "### Procesare Byte 3 ###",
                "movzbl temp_dest_buf+3, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+3, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+3",

                "### Restaurare si Rezultat Final ###",
                "movl temp_eax, %eax",
                "movl temp_ebx, %ebx",
                "movl temp_ecx, %ecx",
                "movl temp_edx, %edx",
                "movl temp_res, <dest>"
            ]
        },
                {
            "name": "orl",
            "param": ["src", "dest"],
            "template": [
                "movl %eax, temp_eax",
                "movl %ebx, temp_ebx",
                "movl %ecx, temp_ecx",
                "movl %edx, temp_edx",

                "movl <dest>, temp_dest_buf",
                "movl <src>, temp_src_buf",

                "### Procesare Byte 0 ###",
                "movzbl temp_dest_buf, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res",

                "### Procesare Byte 1 ###",
                "movzbl temp_dest_buf+1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+1",

                "### Procesare Byte 2 ###",
                "movzbl temp_dest_buf+2, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+2",

                "### Procesare Byte 3 ###",
                "movzbl temp_dest_buf+3, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+3, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+3",

                "### Restaurare si Rezultat Final ###",
                "movl temp_eax, %eax",
                "movl temp_ebx, %ebx",
                "movl temp_ecx, %ecx",
                "movl temp_edx, %edx",
                "movl temp_res, <dest>"
            ]
        },
        {
            "name": "xor",
            "param": ["src", "dest"],
            "template": [
                "movl %eax, temp_eax",
                "movl %ebx, temp_ebx",
                "movl %ecx, temp_ecx",
                "movl %edx, temp_edx",

                "movl <dest>, temp_dest_buf",
                "movl <src>, temp_src_buf",

                "### Byte 0 ###",
                "movzbl temp_dest_buf, %ecx",
                "movl XOR_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res",

                "### Byte 1 ###",
                "movzbl temp_dest_buf+1, %ecx",
                "movl XOR_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+1",

                "### Byte 2 ###",
                "movzbl temp_dest_buf+2, %ecx",
                "movl XOR_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+2",

                "### Byte 3 ###",
                "movzbl temp_dest_buf+3, %ecx",
                "movl XOR_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+3, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+3",

                "### Restore and Final Move ###",
                "movl temp_eax, %eax",
                "movl temp_ebx, %ebx",
                "movl temp_ecx, %ecx",
                "movl temp_edx, %edx",
                "movl temp_res, <dest>"
            ]
        },
        {
            "name": "xorl",
            "param": ["src", "dest"],
            "template": [
                "movl %eax, temp_eax",
                "movl %ebx, temp_ebx",
                "movl %ecx, temp_ecx",
                "movl %edx, temp_edx",

                "movl <dest>, temp_dest_buf",
                "movl <src>, temp_src_buf",

                "### Byte 0 ###",
                "movzbl temp_dest_buf, %ecx",
                "movl XOR_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res",

                "### Byte 1 ###",
                "movzbl temp_dest_buf+1, %ecx",
                "movl XOR_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+1",

                "### Byte 2 ###",
                "movzbl temp_dest_buf+2, %ecx",
                "movl XOR_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+2",

                "### Byte 3 ###",
                "movzbl temp_dest_buf+3, %ecx",
                "movl XOR_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+3, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+3",

                "### Restore and Final Move ###",
                "movl temp_eax, %eax",
                "movl temp_ebx, %ebx",
                "movl temp_ecx, %ecx",
                "movl temp_edx, %edx",
                "movl temp_res, <dest>"
            ]
        },
        {
            "name": "add",
            "param": ["src", "dest"],
            "template": [
                "### 1. Salvare Context si Pregatire Operanzi ###",
                "movl %eax, temp_eax",
                "movl %ebx, temp_ebx",
                "movl %ecx, temp_ecx",
                "movl %edx, temp_edx",
                "movl <dest>, temp_dest_buf",
                "movl <src>, temp_src_buf",
                "movb $0, current_carry",

                "### 2. BYTE 0 (LBS) - Nu exista carry anterior ###",
                "movzbl temp_dest_buf, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",

                "### 3. BYTE 1 ###",
                "movzbl temp_dest_buf+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+1",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",

                "### 4. BYTE 2 ###",
                "movzbl temp_dest_buf+2, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+2",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",

                "### 5. BYTE 3 (MSB) ###",
                "movzbl temp_dest_buf+3, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+3, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+3",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",

                "### 6. Restaurare Scratchpads si Scriere Rezultat Final ###",
                "movl temp_edx, %edx",
                "movl temp_ecx, %ecx",
                "movl temp_ebx, %ebx",
                "movl temp_eax, %eax",
                "movl temp_res, <dest>"
            ]
        },
                {
            "name": "addl",
            "param": ["src", "dest"],
            "template": [
                "### 1. Salvare Context si Pregatire Operanzi ###",
                "movl %eax, temp_eax",
                "movl %ebx, temp_ebx",
                "movl %ecx, temp_ecx",
                "movl %edx, temp_edx",
                "movl <dest>, temp_dest_buf",
                "movl <src>, temp_src_buf",
                "movb $0, current_carry",

                "### 2. BYTE 0 (LBS) - Nu exista carry anterior ###",
                "movzbl temp_dest_buf, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",

                "### 3. BYTE 1 ###",
                "movzbl temp_dest_buf+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+1",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",

                "### 4. BYTE 2 ###",
                "movzbl temp_dest_buf+2, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+2",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",

                "### 5. BYTE 3 (MSB) ###",
                "movzbl temp_dest_buf+3, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+3, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+3",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",

                "### 6. Restaurare Scratchpads si Scriere Rezultat Final ###",
                "movl temp_edx, %edx",
                "movl temp_ecx, %ecx",
                "movl temp_ebx, %ebx",
                "movl temp_eax, %eax",
                "movl temp_res, <dest>"
            ]
        },

        {
            "name": "sub",
            "param": ["src", "dest"],
            "template": [
                "### 1. Salvare Context si Pregatire ###",
                "movl %eax, temp_eax",
                "movl %ebx, temp_ebx",
                "movl %ecx, temp_ecx",
                "movl %edx, temp_edx",
                "movl <dest>, temp_dest_buf",
                "movl <src>, temp_src_buf",

                "### 2. Negarea Sursei (NOT) pentru Complement fata de 2 ###",
                "movzbl temp_src_buf, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_src_buf",

                "movzbl temp_src_buf+1, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_src_buf+1",

                "movzbl temp_src_buf+2, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_src_buf+2",

                "movzbl temp_src_buf+3, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_src_buf+3",

                "### 3. Setare Carry Initial la 1 (Finalizarea Complementului fata de 2) ###",
                "movb $1, current_carry",

                "### 4. BYTE 0 (LBS) - Proces de adunare ###",
                "movzbl temp_dest_buf, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                
                "movzbl temp_res, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",

                "### 5. BYTE 1 ###",
                "movzbl temp_dest_buf+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+1",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",

                "### 6. BYTE 2 ###",
                "movzbl temp_dest_buf+2, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+2",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",

                "### 7. BYTE 3 ###",
                "movzbl temp_dest_buf+3, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+3, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+3",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",

                "### 8. Restaurare Scratchpads si Scriere Rezultat ###",
                "movl temp_edx, %edx",
                "movl temp_ecx, %ecx",
                "movl temp_ebx, %ebx",
                "movl temp_eax, %eax",
                "movl temp_res, <dest>"
            ]
        },
                {
            "name": "subl",
            "param": ["src", "dest"],
            "template": [
                "### 1. Salvare Context si Pregatire ###",
                "movl %eax, temp_eax",
                "movl %ebx, temp_ebx",
                "movl %ecx, temp_ecx",
                "movl %edx, temp_edx",
                "movl <dest>, temp_dest_buf",
                "movl <src>, temp_src_buf",

                "### 2. Negarea Sursei (NOT) pentru Complement fata de 2 ###",
                "movzbl temp_src_buf, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_src_buf",

                "movzbl temp_src_buf+1, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_src_buf+1",

                "movzbl temp_src_buf+2, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_src_buf+2",

                "movzbl temp_src_buf+3, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_src_buf+3",

                "### 3. Setare Carry Initial la 1 (Finalizarea Complementului fata de 2) ###",
                "movb $1, current_carry",

                "### 4. BYTE 0 (LBS) - Proces de adunare ###",
                "movzbl temp_dest_buf, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                
                "movzbl temp_res, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",

                "### 5. BYTE 1 ###",
                "movzbl temp_dest_buf+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+1",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",

                "### 6. BYTE 2 ###",
                "movzbl temp_dest_buf+2, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+2",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",

                "### 7. BYTE 3 ###",
                "movzbl temp_dest_buf+3, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf+3, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+3",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",

                "### 8. Restaurare Scratchpads si Scriere Rezultat ###",
                "movl temp_edx, %edx",
                "movl temp_ecx, %ecx",
                "movl temp_ebx, %ebx",
                "movl temp_eax, %eax",
                "movl temp_res, <dest>"
            ]
        },

       {
            "name": "shl",
            "param": ["src", "dest"],
            "template": [
                "### 1. Salvare Context si Pregatire Coloana ###",
                "movl %eax, temp_eax",
                "movl %ebx, temp_ebx",
                "movl %ecx, temp_ecx",
                "movl %edx, temp_edx",
                "movl <src>, %eax",
                "movzbl %al, %eax",
                "leal (,%eax, 4), %eax", 
                "movl %eax, temp_src_buf",
                "movl <dest>, temp_dest_buf",

                "### 2. Imaginea 0 (Byte 0) -> temp_res ###",
                "movzbl temp_dest_buf, %ecx",
                "movl SHL_B0_PTR(,%ecx, 4), %edx",
                "movl temp_src_buf, %ebx",
                "movl (%edx, %ebx, 1), %eax",
                "movl %eax, temp_res",

                "### 3. Imaginea 1 (Byte 1) si Prima Adunare ###",
                "movzbl temp_dest_buf+1, %ecx",
                "movl SHL_B1_PTR(,%ecx, 4), %edx",
                "movl (%edx, %ebx, 1), %eax",
                "movl %eax, temp_src_buf_2",

                "movb $0, current_carry",
                "### Byte 0 ADD ###",
                "movzbl temp_res, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf_2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "### Byte 1 ADD ###",
                "movzbl temp_res+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf_2+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+1",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "### Byte 2 ADD ###",
                "movzbl temp_res+2, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf_2+2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+2",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "### Byte 3 ADD ###",
                "movzbl temp_res+3, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf_2+3, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+3",

                "### 4. Imaginea 2 (Byte 2) si A doua Adunare ###",
                "movzbl temp_dest_buf+2, %ecx",
                "movl SHL_B2_PTR(,%ecx, 4), %edx",
                "movl temp_src_buf, %ebx",
                "movl (%edx, %ebx, 1), %eax",
                "movl %eax, temp_src_buf_2",

                "movb $0, current_carry",
                "### Byte 0 ADD ###",
                "movzbl temp_res, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf_2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "### Byte 1 ADD ###",
                "movzbl temp_res+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf_2+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+1",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "### Byte 2 ADD ###",
                "movzbl temp_res+2, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf_2+2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+2",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "### Byte 3 ADD ###",
                "movzbl temp_res+3, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf_2+3, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+3",

                "### 5. Imaginea 3 (Byte 3) si A treia Adunare ###",
                "movzbl temp_dest_buf+3, %ecx",
                "movl SHL_B3_PTR(,%ecx, 4), %edx",
                "movl temp_src_buf, %ebx",
                "movl (%edx, %ebx, 1), %eax",
                "movl %eax, temp_src_buf_2",

                "movb $0, current_carry",
                "### Byte 0 ADD ###",
                "movzbl temp_res, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf_2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "### Byte 1 ADD ###",
                "movzbl temp_res+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf_2+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+1",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "### Byte 2 ADD ###",
                "movzbl temp_res+2, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf_2+2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+2",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "### Byte 3 ADD ###",
                "movzbl temp_res+3, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf_2+3, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+3",

                "### 6. Restaurare si Scriere ###",
                "movl temp_edx, %edx",
                "movl temp_ecx, %ecx",
                "movl temp_ebx, %ebx",
                "movl temp_eax, %eax",
                "movl temp_res, <dest>"
            ]
        },

        {
            "name": "shr",
            "param": ["src", "dest"],
            "template": [
                "### 1. Salvare Context si Pregatire Coloana ###",
                "movl %eax, temp_eax",
                "movl %ebx, temp_ebx",
                "movl %ecx, temp_ecx",
                "movl %edx, temp_edx",
                "movl <src>, %eax",
                "movzbl %al, %eax",
                "leal (,%eax, 4), %eax", 
                "movl %eax, temp_src_buf",
                "movl <dest>, temp_dest_buf",

                "### 2. Imaginea 0 (Byte 0) -> temp_res ###",
                "movzbl temp_dest_buf, %ecx",
                "movl SHR_B0_PTR(,%ecx, 4), %edx",
                "movl temp_src_buf, %ebx",
                "movl (%edx, %ebx, 1), %eax",
                "movl %eax, temp_res",

                "### 3. Imaginea 1 (Byte 1) + Adunare ###",
                "movzbl temp_dest_buf+1, %ecx",
                "movl SHR_B1_PTR(,%ecx, 4), %edx",
                "movl (%edx, %ebx, 1), %eax",
                "movl %eax, temp_src_buf_2",

                "movb $0, current_carry",
                "movzbl temp_res, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf_2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                
                "movzbl temp_res+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf_2+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+1",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                
                "movzbl temp_res+2, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf_2+2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+2",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                
                "movzbl temp_res+3, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf_2+3, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+3",

                "### 4. Imaginea 2 (Byte 2) + Adunare ###",
                "movzbl temp_dest_buf+2, %ecx",
                "movl SHR_B2_PTR(,%ecx, 4), %edx",
                "movl temp_src_buf, %ebx",
                "movl (%edx, %ebx, 1), %eax",
                "movl %eax, temp_src_buf_2",
                "movb $0, current_carry",
                "### [BYTE 0 ADD] ###",
                "movzbl temp_res, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf_2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "### [BYTE 1 ADD] ###",
                "movzbl temp_res+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf_2+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+1",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "### [BYTE 2 ADD] ###",
                "movzbl temp_res+2, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf_2+2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+2",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "### [BYTE 3 ADD] ###",
                "movzbl temp_res+3, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf_2+3, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+3",

                "### 5. Imaginea 3 (Byte 3) + Adunare ###",
                "movzbl temp_dest_buf+3, %ecx",
                "movl SHR_B3_PTR(,%ecx, 4), %edx",
                "movl temp_src_buf, %ebx",
                "movl (%edx, %ebx, 1), %eax",
                "movl %eax, temp_src_buf_2",
                "movb $0, current_carry",
                "### [Repeti logica ADD pentru Byte 0, 1, 2, 3] ###",
                "movzbl temp_res, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf_2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl temp_res+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf_2+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+1",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl temp_res+2, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf_2+2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+2",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl temp_res+3, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_src_buf_2+3, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+3",

                "### 6. Restaurare si Scriere ###",
                "movl temp_edx, %edx",
                "movl temp_ecx, %ecx",
                "movl temp_ebx, %ebx",
                "movl temp_eax, %eax",
                "movl temp_res, <dest>"
            ]
        },
         {
            "name": "mul",
            "param": ["src"],
            "template": [
               "### 1. Salvare Context si Initializare ###",
                "movl %eax, temp_eax",
                "movl %ebx, temp_ebx",
                "movl %ecx, temp_ecx",
                "movl %edx, temp_edx",
                "movl %eax, temp_eax_buf",
                "movl <src>, temp_src_buf",
                "movl $0, temp_res",

                "### 2. Perechea a0 * b0 (Offset 0) ###",
                "movzbl temp_eax_buf, %ecx",
                "movzbl temp_src_buf, %ebx",
                "movl MUL_LOW_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res",
                "movl MUL_HIGH_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+1",

                "### 3. Perechea a0 * b1 (Offset 1) ###",
                "movzbl temp_src_buf+1, %ebx",
                "movl MUL_LOW_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, prod_low",
                "movl MUL_HIGH_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, prod_high",
                "### ADD prod_low la temp_res+1 ###",
                "movb $0, current_carry",
                "movzbl temp_res+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl prod_low, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+1",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "### Propagare Carry + prod_high la temp_res+2 ###",
                "movzbl temp_res+2, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl prod_high, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+2",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl temp_res+3, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+3",
                "### 4. Perechea a1 * b0 (Offset 1) ###",
                "movzbl temp_eax_buf+1, %ecx",
                "movzbl temp_src_buf, %ebx",
                "movl MUL_LOW_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, prod_low",
                "movl MUL_HIGH_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, prod_high",
                "### ADD prod_low la temp_res+1 ###",
                "movb $0, current_carry",
                "movzbl temp_res+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl prod_low, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+1",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "### Propagare prod_high + carry la temp_res+2 ###",
                "movzbl temp_res+2, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl prod_high, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c1",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+2",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %cl",
                "movb %cl, temp_c2",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl temp_res+3, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+3",

                "### 5. Perechea a1 * b1 (Offset 2) ###",
                "movzbl temp_eax_buf+1, %ecx",      
                "movzbl temp_src_buf+1, %ebx",
                "movl MUL_LOW_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, prod_low",
                "movl MUL_HIGH_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, prod_high",
                "### ADD prod_low la temp_res+2 ###",
                "movb $0, current_carry",
                "movzbl temp_res+2, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl prod_low, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+2",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "### Propagare prod_high + carry la temp_res+3 ###",
                "movzbl temp_res+3, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl prod_high, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+3",

                "### 6. Perechea a2 * b0 (Offset 2) ###",
                "movzbl temp_eax_buf+2, %ecx",
                "movzbl temp_src_buf, %ebx",
                "movl MUL_LOW_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, prod_low",
                "movl MUL_HIGH_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, prod_high",
                "### ADD la temp_res+2 ###",
                "movb $0, current_carry",
                "movzbl temp_res+2, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl prod_low, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+2",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "### Propagare finala la temp_res+3 ###",
                "movzbl temp_res+3, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl prod_high, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_res+3",

                "### 7. Finalizare ###",
                "movl temp_ebx, %ebx",
                "movl temp_ecx, %ecx",
                "movl temp_edx, %edx",
                "movl temp_eax, %eax",
                "movl temp_res, %eax",
                "movl $0, %edx"
            ]
        }, 
        {
            "name": "div",
            "param": ["src"],
            "template": [
                "### 1. Salvare Context si Initializare ###",
                "movl %eax, temp_eax",
                "movl %ebx, temp_ebx",
                "movl %ecx, temp_ecx",
                "movl %edx, temp_edx",
                "movl %eax, div_quotient",
                "movl <src>, %eax",
                "movl %eax, div_divisor",
                "movl $0, div_remainder",

                "### --- ITERATIA 15 (Prima) --- ###",
                
                "### A. Shift Combined: Remainder = (Remainder << 1) | MSB(Quotient) ###",
                "### Extragere MSB din div_quotient (bit 15) ###",
                "movzbl div_quotient+1, %ecx",
                "movb GET_MSB_LUT(%ecx), %al",
                "movb %al, temp_c1",

                "### Remainder = Remainder + Remainder (Shift 1) ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_remainder, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",

                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_remainder+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder+1",

                "### Adunare MSB extras la Remainder ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_c1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder+1",

                "### Quotient = Quotient << 1 ###",
                "movzbl div_quotient, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_quotient, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_quotient+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_quotient+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient+1",

                "### B. Scadere: div_temp_res = Remainder - Divisor ###",
                "### Pas 1: NOT divisor ###",
                "movzbl div_divisor, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, div_temp_a",
                "movzbl div_divisor+1, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, div_temp_a+1",
                "### Pas 2: NOT(divisor) + 1 ###",
                "movzbl div_temp_a, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movl $1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_a",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_temp_a+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_a+1",
                "### Pas 3: Remainder + [NOT(divisor)+1] ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_temp_a, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_temp_a+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res+1",
                "### Carry final in byte 3 pentru semn ###",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res+3",
                "movzbl div_temp_res+3, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, div_temp_res+3",

                "### C. Verificare Semn si Update ###",
                "movzbl div_temp_res+3, %ecx",
                "movb IS_NEG_BYTE_LUT(%ecx), %al",
                "movzbl %al, %eax",
                "movl SIGN_TO_MASK_LUT(,%eax, 4), %ebx",
                "movl %ebx, div_mask",

                "### Quotient Bit Update (Bit 0 |= !is_negative) ###",
                "movzbl div_mask, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movl $1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl div_quotient, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient",

                "### Remainder Selection (MUX) ###",
                "### Byte 0 ###",
                "movzbl div_temp_res, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl div_mask, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_c1",
                "movzbl div_mask, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_c2",
                "movzbl div_remainder, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "### Byte 1 ###",
                "movzbl div_temp_res+1, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl div_mask, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_c1",
                "movzbl div_remainder+1, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder+1",

                "### --- ITERATIA 14 --- ###",
                "### 1. Shift Combined (Remainder:Quotient << 1) ###",
                "movzbl div_quotient+1, %ecx",
                "movb GET_MSB_LUT(%ecx), %al",
                "movb %al, temp_c1",
                "### Remainder = Remainder + Remainder ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_remainder, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_remainder+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder+1",
                "### Adauga bitul extras (MSB) la Remainder ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_c1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder+1",
                "### Quotient = Quotient << 1 ###",
                "movzbl div_quotient, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_quotient, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_quotient+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_quotient+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient+1",
                "### 2. Scadere: div_temp_res = Remainder - Divisor ###",
                "### Pas: NOT divisor ###",
                "movzbl div_divisor, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, div_temp_a",
                "movzbl div_divisor+1, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, div_temp_a+1",
                "### Pas: NOT + 1 (Negatie 2's complement) ###",
                "movzbl div_temp_a, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movl $1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_a",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_temp_a+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_a+1",
                "### Pas: div_temp_res = Remainder + div_temp_a ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_temp_a, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_temp_a+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res+1",
                "### Extragere semn (Carry Out inversat) ###",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, is_negative",
                "### 3. Verificare Semn si Masca ###",
                "movzbl is_negative, %ecx",
                "movb IS_NEG_BYTE_LUT(%ecx), %al",
                "movzbl %al, %eax",
                "movl SIGN_TO_MASK_LUT(,%eax, 4), %ebx",
                "movl %ebx, div_mask",
                "### 4. Update Quotient Bit 0 (Quotient |= !is_negative) ###",
                "movzbl div_mask, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movl $1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl div_quotient, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient",
                "### 5. Remainder Selection (MUX: New if fits, Old if not) ###",
                "### Byte 0 ###",
                "movzbl div_temp_res, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl div_mask, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_c1",
                "movzbl div_mask, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_c2",
                "movzbl div_remainder, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "### Byte 1 ###",
                "movzbl div_temp_res+1, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl div_mask, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_c1",
                "movzbl div_remainder+1, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder+1",

                "### --- ITERATIA 13 --- ###",
                "### 1. Shift Combined (Remainder:Quotient << 1) ###",
                "movzbl div_quotient+1, %ecx",
                "movb GET_MSB_LUT(%ecx), %al",
                "movb %al, temp_c1",
                "### Remainder = Remainder + Remainder ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_remainder, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_remainder+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder+1",
                "### Adauga bitul extras (MSB) la Remainder ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_c1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder+1",
                "### Quotient = Quotient << 1 ###",
                "movzbl div_quotient, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_quotient, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_quotient+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_quotient+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient+1",
                "### 2. Scadere: div_temp_res = Remainder - Divisor ###",
                "### Pas: NOT divisor ###",
                "movzbl div_divisor, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, div_temp_a",
                "movzbl div_divisor+1, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, div_temp_a+1",
                "### Pas: NOT + 1 (Negatie 2's complement) ###",
                "movzbl div_temp_a, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movl $1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_a",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_temp_a+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_a+1",
                "### Pas: div_temp_res = Remainder + div_temp_a ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_temp_a, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_temp_a+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res+1",
                "### Extragere semn (Carry Out inversat) ###",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, is_negative",
                "### 3. Verificare Semn si Masca ###",
                "movzbl is_negative, %ecx",
                "movb IS_NEG_BYTE_LUT(%ecx), %al",
                "movzbl %al, %eax",
                "movl SIGN_TO_MASK_LUT(,%eax, 4), %ebx",
                "movl %ebx, div_mask",
                "### 4. Update Quotient Bit 0 (Quotient |= !is_negative) ###",
                "movzbl div_mask, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movl $1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl div_quotient, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient",
                "### 5. Remainder Selection (MUX: New if fits, Old if not) ###",
                "### Byte 0 ###",
                "movzbl div_temp_res, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl div_mask, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_c1",
                "movzbl div_mask, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_c2",
                "movzbl div_remainder, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "### Byte 1 ###",
                "movzbl div_temp_res+1, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl div_mask, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_c1",
                "movzbl div_remainder+1, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder+1",

                "### --- ITERATIA 12 --- ###",
                "### 1. Shift Combined (Remainder:Quotient << 1) ###",
                "movzbl div_quotient+1, %ecx",
                "movb GET_MSB_LUT(%ecx), %al",
                "movb %al, temp_c1",
                "### Remainder = Remainder + Remainder ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_remainder, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_remainder+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder+1",
                "### Adauga bitul extras (MSB) la Remainder ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_c1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder+1",
                "### Quotient = Quotient << 1 ###",
                "movzbl div_quotient, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_quotient, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_quotient+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_quotient+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient+1",
                "### 2. Scadere: div_temp_res = Remainder - Divisor ###",
                "### Pas: NOT divisor ###",
                "movzbl div_divisor, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, div_temp_a",
                "movzbl div_divisor+1, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, div_temp_a+1",
                "### Pas: NOT + 1 (Negatie 2's complement) ###",
                "movzbl div_temp_a, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movl $1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_a",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_temp_a+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_a+1",
                "### Pas: div_temp_res = Remainder + div_temp_a ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_temp_a, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_temp_a+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res+1",
                "### Extragere semn (Carry Out inversat) ###",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, is_negative",
                "### 3. Verificare Semn si Masca ###",
                "movzbl is_negative, %ecx",
                "movb IS_NEG_BYTE_LUT(%ecx), %al",
                "movzbl %al, %eax",
                "movl SIGN_TO_MASK_LUT(,%eax, 4), %ebx",
                "movl %ebx, div_mask",
                "### 4. Update Quotient Bit 0 (Quotient |= !is_negative) ###",
                "movzbl div_mask, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movl $1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl div_quotient, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient",
                "### 5. Remainder Selection (MUX: New if fits, Old if not) ###",
                "### Byte 0 ###",
                "movzbl div_temp_res, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl div_mask, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_c1",
                "movzbl div_mask, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_c2",
                "movzbl div_remainder, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "### Byte 1 ###",
                "movzbl div_temp_res+1, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl div_mask, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_c1",
                "movzbl div_remainder+1, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder+1",

                "### --- ITERATIA 11 --- ###",
                "### 1. Shift Combined (Remainder:Quotient << 1) ###",
                "movzbl div_quotient+1, %ecx",
                "movb GET_MSB_LUT(%ecx), %al",
                "movb %al, temp_c1",
                "### Remainder = Remainder + Remainder ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_remainder, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_remainder+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder+1",
                "### Adauga bitul extras (MSB) la Remainder ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_c1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder+1",
                "### Quotient = Quotient << 1 ###",
                "movzbl div_quotient, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_quotient, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_quotient+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_quotient+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient+1",
                "### 2. Scadere: div_temp_res = Remainder - Divisor ###",
                "### Pas: NOT divisor ###",
                "movzbl div_divisor, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, div_temp_a",
                "movzbl div_divisor+1, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, div_temp_a+1",
                "### Pas: NOT + 1 (Negatie 2's complement) ###",
                "movzbl div_temp_a, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movl $1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_a",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_temp_a+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_a+1",
                "### Pas: div_temp_res = Remainder + div_temp_a ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_temp_a, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_temp_a+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res+1",
                "### Extragere semn (Carry Out inversat) ###",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, is_negative",
                "### 3. Verificare Semn si Masca ###",
                "movzbl is_negative, %ecx",
                "movb IS_NEG_BYTE_LUT(%ecx), %al",
                "movzbl %al, %eax",
                "movl SIGN_TO_MASK_LUT(,%eax, 4), %ebx",
                "movl %ebx, div_mask",
                "### 4. Update Quotient Bit 0 (Quotient |= !is_negative) ###",
                "movzbl div_mask, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movl $1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl div_quotient, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient",
                "### 5. Remainder Selection (MUX: New if fits, Old if not) ###",
                "### Byte 0 ###",
                "movzbl div_temp_res, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl div_mask, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_c1",
                "movzbl div_mask, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_c2",
                "movzbl div_remainder, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "### Byte 1 ###",
                "movzbl div_temp_res+1, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl div_mask, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_c1",
                "movzbl div_remainder+1, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder+1",

                "### --- ITERATIA 10 --- ###",
                "### 1. Shift Combined (Remainder:Quotient << 1) ###",
                "movzbl div_quotient+1, %ecx",
                "movb GET_MSB_LUT(%ecx), %al",
                "movb %al, temp_c1",
                "### Remainder = Remainder + Remainder ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_remainder, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_remainder+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder+1",
                "### Adauga bitul extras (MSB) la Remainder ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_c1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder+1",
                "### Quotient = Quotient << 1 ###",
                "movzbl div_quotient, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_quotient, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_quotient+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_quotient+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient+1",
                "### 2. Scadere: div_temp_res = Remainder - Divisor ###",
                "### Pas: NOT divisor ###",
                "movzbl div_divisor, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, div_temp_a",
                "movzbl div_divisor+1, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, div_temp_a+1",
                "### Pas: NOT + 1 (Negatie 2's complement) ###",
                "movzbl div_temp_a, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movl $1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_a",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_temp_a+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_a+1",
                "### Pas: div_temp_res = Remainder + div_temp_a ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_temp_a, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_temp_a+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res+1",
                "### Extragere semn (Carry Out inversat) ###",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, is_negative",
                "### 3. Verificare Semn si Masca ###",
                "movzbl is_negative, %ecx",
                "movb IS_NEG_BYTE_LUT(%ecx), %al",
                "movzbl %al, %eax",
                "movl SIGN_TO_MASK_LUT(,%eax, 4), %ebx",
                "movl %ebx, div_mask",
                "### 4. Update Quotient Bit 0 (Quotient |= !is_negative) ###",
                "movzbl div_mask, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movl $1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl div_quotient, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient",
                "### 5. Remainder Selection (MUX: New if fits, Old if not) ###",
                "### Byte 0 ###",
                "movzbl div_temp_res, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl div_mask, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_c1",
                "movzbl div_mask, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_c2",
                "movzbl div_remainder, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "### Byte 1 ###",
                "movzbl div_temp_res+1, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl div_mask, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_c1",
                "movzbl div_remainder+1, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder+1",

                "### --- ITERATIA 9 --- ###",
                "### 1. Shift Combined (Remainder:Quotient << 1) ###",
                "movzbl div_quotient+1, %ecx",
                "movb GET_MSB_LUT(%ecx), %al",
                "movb %al, temp_c1",
                "### Remainder = Remainder + Remainder ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_remainder, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_remainder+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder+1",
                "### Adauga bitul extras (MSB) la Remainder ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_c1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder+1",
                "### Quotient = Quotient << 1 ###",
                "movzbl div_quotient, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_quotient, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_quotient+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_quotient+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient+1",
                "### 2. Scadere: div_temp_res = Remainder - Divisor ###",
                "### Pas: NOT divisor ###",
                "movzbl div_divisor, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, div_temp_a",
                "movzbl div_divisor+1, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, div_temp_a+1",
                "### Pas: NOT + 1 (Negatie 2's complement) ###",
                "movzbl div_temp_a, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movl $1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_a",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_temp_a+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_a+1",
                "### Pas: div_temp_res = Remainder + div_temp_a ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_temp_a, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_temp_a+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res+1",
                "### Extragere semn (Carry Out inversat) ###",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, is_negative",
                "### 3. Verificare Semn si Masca ###",
                "movzbl is_negative, %ecx",
                "movb IS_NEG_BYTE_LUT(%ecx), %al",
                "movzbl %al, %eax",
                "movl SIGN_TO_MASK_LUT(,%eax, 4), %ebx",
                "movl %ebx, div_mask",
                "### 4. Update Quotient Bit 0 (Quotient |= !is_negative) ###",
                "movzbl div_mask, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movl $1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl div_quotient, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient",
                "### 5. Remainder Selection (MUX: New if fits, Old if not) ###",
                "### Byte 0 ###",
                "movzbl div_temp_res, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl div_mask, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_c1",
                "movzbl div_mask, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_c2",
                "movzbl div_remainder, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "### Byte 1 ###",
                "movzbl div_temp_res+1, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl div_mask, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_c1",
                "movzbl div_remainder+1, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder+1",

                "### --- ITERATIA 8 --- ###",
                "### 1. Shift Combined (Remainder:Quotient << 1) ###",
                "movzbl div_quotient+1, %ecx",
                "movb GET_MSB_LUT(%ecx), %al",
                "movb %al, temp_c1",
                "### Remainder = Remainder + Remainder ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_remainder, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_remainder+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder+1",
                "### Adauga bitul extras (MSB) la Remainder ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_c1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder+1",
                "### Quotient = Quotient << 1 ###",
                "movzbl div_quotient, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_quotient, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_quotient+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_quotient+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient+1",
                "### 2. Scadere: div_temp_res = Remainder - Divisor ###",
                "### Pas: NOT divisor ###",
                "movzbl div_divisor, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, div_temp_a",
                "movzbl div_divisor+1, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, div_temp_a+1",
                "### Pas: NOT + 1 (Negatie 2's complement) ###",
                "movzbl div_temp_a, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movl $1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_a",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_temp_a+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_a+1",
                "### Pas: div_temp_res = Remainder + div_temp_a ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_temp_a, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_temp_a+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res+1",
                "### Extragere semn (Carry Out inversat) ###",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, is_negative",
                "### 3. Verificare Semn si Masca ###",
                "movzbl is_negative, %ecx",
                "movb IS_NEG_BYTE_LUT(%ecx), %al",
                "movzbl %al, %eax",
                "movl SIGN_TO_MASK_LUT(,%eax, 4), %ebx",
                "movl %ebx, div_mask",
                "### 4. Update Quotient Bit 0 (Quotient |= !is_negative) ###",
                "movzbl div_mask, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movl $1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl div_quotient, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient",
                "### 5. Remainder Selection (MUX: New if fits, Old if not) ###",
                "### Byte 0 ###",
                "movzbl div_temp_res, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl div_mask, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_c1",
                "movzbl div_mask, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_c2",
                "movzbl div_remainder, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "### Byte 1 ###",
                "movzbl div_temp_res+1, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl div_mask, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_c1",
                "movzbl div_remainder+1, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder+1",


                "### --- ITERATIA 7 --- ###",
                "### 1. Shift Combined ###",
                "movzbl div_quotient+1, %ecx",
                "movb GET_MSB_LUT(%ecx), %al",
                "movb %al, temp_c1",
                "### Remainder = Remainder + Remainder ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_remainder, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_remainder+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder+1",
                "### Adauga bitul extras in Remainder ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_c1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "### Quotient = Quotient << 1 ###",
                "movzbl div_quotient, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_quotient, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_quotient+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_quotient+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient+1",
                "### 2. Scadere: div_temp_res = Remainder - Divisor ###",
                "movzbl div_divisor, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, div_temp_a",
                "movzbl div_divisor+1, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, div_temp_a+1",
                "### NOT + 1 ###",
                "movzbl div_temp_a, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movl $1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_a",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl div_temp_a+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_a+1",
                "### Final subtraction ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_temp_a, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_temp_a+1, %ebx",
                "movb (%edx, %ebx, 1), %cl",
                "movzbl %al, %ebx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res+1",
                "### Carry Check (Semn) ###",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res+3",
                "movzbl div_temp_res+3, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, is_negative",
                "### 3. MUX Selection (Actualizeaza Remainder si Quotient) ###",
                "movzbl is_negative, %eax",
                "movl SIGN_TO_MASK_LUT(,%eax, 4), %ebx",
                "movl %ebx, div_mask",
                "### Update Quotient bit 0 ###",
                "movzbl div_mask, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movl $1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl div_quotient, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient",
                "### Update Remainder (Select) ###",
                "movzbl div_temp_res, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl div_mask, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_c1",
                "movzbl div_mask, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_c2",
                "movzbl div_remainder, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",

                "### --- ITERATIA 6 --- ###",
                "### 1. Shift Combined ###",
                "movzbl div_quotient+1, %ecx",
                "movb GET_MSB_LUT(%ecx), %al",
                "movb %al, temp_c1",
                "### Remainder = Remainder + Remainder ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_remainder, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_remainder+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder+1",
                "### Adauga bitul extras in Remainder ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_c1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "### Quotient = Quotient << 1 ###",
                "movzbl div_quotient, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_quotient, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_quotient+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_quotient+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient+1",
                "### 2. Scadere: div_temp_res = Remainder - Divisor ###",
                "movzbl div_divisor, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, div_temp_a",
                "movzbl div_divisor+1, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, div_temp_a+1",
                "### NOT + 1 ###",
                "movzbl div_temp_a, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movl $1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_a",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl div_temp_a+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_a+1",
                "### Final subtraction ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_temp_a, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_temp_a+1, %ebx",
                "movb (%edx, %ebx, 1), %cl",
                "movzbl %al, %ebx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res+1",
                "### Carry Check (Semn) ###",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res+3",
                "movzbl div_temp_res+3, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, is_negative",
                "### 3. MUX Selection (Actualizeaza Remainder si Quotient) ###",
                "movzbl is_negative, %eax",
                "movl SIGN_TO_MASK_LUT(,%eax, 4), %ebx",
                "movl %ebx, div_mask",
                "### Update Quotient bit 0 ###",
                "movzbl div_mask, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movl $1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl div_quotient, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient",
                "### Update Remainder (Select) ###",
                "movzbl div_temp_res, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl div_mask, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_c1",
                "movzbl div_mask, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_c2",
                "movzbl div_remainder, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",

                "### --- ITERATIA 5 --- ###",
                "### 1. Shift Combined ###",
                "movzbl div_quotient+1, %ecx",
                "movb GET_MSB_LUT(%ecx), %al",
                "movb %al, temp_c1",
                "### Remainder = Remainder + Remainder ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_remainder, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_remainder+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder+1",
                "### Adauga bitul extras in Remainder ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_c1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "### Quotient = Quotient << 1 ###",
                "movzbl div_quotient, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_quotient, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_quotient+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_quotient+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient+1",
                "### 2. Scadere: div_temp_res = Remainder - Divisor ###",
                "movzbl div_divisor, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, div_temp_a",
                "movzbl div_divisor+1, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, div_temp_a+1",
                "### NOT + 1 ###",
                "movzbl div_temp_a, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movl $1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_a",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl div_temp_a+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_a+1",
                "### Final subtraction ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_temp_a, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_temp_a+1, %ebx",
                "movb (%edx, %ebx, 1), %cl",
                "movzbl %al, %ebx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res+1",
                "### Carry Check (Semn) ###",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res+3",
                "movzbl div_temp_res+3, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, is_negative",
                "### 3. MUX Selection (Actualizeaza Remainder si Quotient) ###",
                "movzbl is_negative, %eax",
                "movl SIGN_TO_MASK_LUT(,%eax, 4), %ebx",
                "movl %ebx, div_mask",
                "### Update Quotient bit 0 ###",
                "movzbl div_mask, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movl $1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl div_quotient, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient",
                "### Update Remainder (Select) ###",
                "movzbl div_temp_res, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl div_mask, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_c1",
                "movzbl div_mask, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_c2",
                "movzbl div_remainder, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",

                "### --- ITERATIA 4 --- ###",
                "### 1. Shift Combined ###",
                "movzbl div_quotient+1, %ecx",
                "movb GET_MSB_LUT(%ecx), %al",
                "movb %al, temp_c1",
                "### Remainder = Remainder + Remainder ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_remainder, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_remainder+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder+1",
                "### Adauga bitul extras in Remainder ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_c1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "### Quotient = Quotient << 1 ###",
                "movzbl div_quotient, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_quotient, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_quotient+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_quotient+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient+1",
                "### 2. Scadere: div_temp_res = Remainder - Divisor ###",
                "movzbl div_divisor, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, div_temp_a",
                "movzbl div_divisor+1, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, div_temp_a+1",
                "### NOT + 1 ###",
                "movzbl div_temp_a, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movl $1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_a",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl div_temp_a+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_a+1",
                "### Final subtraction ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_temp_a, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_temp_a+1, %ebx",
                "movb (%edx, %ebx, 1), %cl",
                "movzbl %al, %ebx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res+1",
                "### Carry Check (Semn) ###",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res+3",
                "movzbl div_temp_res+3, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, is_negative",
                "### 3. MUX Selection (Actualizeaza Remainder si Quotient) ###",
                "movzbl is_negative, %eax",
                "movl SIGN_TO_MASK_LUT(,%eax, 4), %ebx",
                "movl %ebx, div_mask",
                "### Update Quotient bit 0 ###",
                "movzbl div_mask, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movl $1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl div_quotient, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient",
                "### Update Remainder (Select) ###",
                "movzbl div_temp_res, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl div_mask, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_c1",
                "movzbl div_mask, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_c2",
                "movzbl div_remainder, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",

                "### --- ITERATIA 3 --- ###",
                "### 1. Shift Combined ###",
                "movzbl div_quotient+1, %ecx",
                "movb GET_MSB_LUT(%ecx), %al",
                "movb %al, temp_c1",
                "### Remainder = Remainder + Remainder ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_remainder, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_remainder+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder+1",
                "### Adauga bitul extras in Remainder ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_c1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "### Quotient = Quotient << 1 ###",
                "movzbl div_quotient, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_quotient, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_quotient+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_quotient+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient+1",
                "### 2. Scadere: div_temp_res = Remainder - Divisor ###",
                "movzbl div_divisor, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, div_temp_a",
                "movzbl div_divisor+1, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, div_temp_a+1",
                "### NOT + 1 ###",
                "movzbl div_temp_a, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movl $1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_a",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl div_temp_a+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_a+1",
                "### Final subtraction ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_temp_a, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_temp_a+1, %ebx",
                "movb (%edx, %ebx, 1), %cl",
                "movzbl %al, %ebx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res+1",
                "### Carry Check (Semn) ###",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res+3",
                "movzbl div_temp_res+3, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, is_negative",
                "### 3. MUX Selection (Actualizeaza Remainder si Quotient) ###",
                "movzbl is_negative, %eax",
                "movl SIGN_TO_MASK_LUT(,%eax, 4), %ebx",
                "movl %ebx, div_mask",
                "### Update Quotient bit 0 ###",
                "movzbl div_mask, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movl $1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl div_quotient, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient",
                "### Update Remainder (Select) ###",
                "movzbl div_temp_res, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl div_mask, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_c1",
                "movzbl div_mask, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_c2",
                "movzbl div_remainder, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",

                "### --- ITERATIA 2 --- ###",
                "### 1. Shift Combined ###",
                "movzbl div_quotient+1, %ecx",
                "movb GET_MSB_LUT(%ecx), %al",
                "movb %al, temp_c1",
                "### Remainder = Remainder + Remainder ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_remainder, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_remainder+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder+1",
                "### Adauga bitul extras in Remainder ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_c1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "### Quotient = Quotient << 1 ###",
                "movzbl div_quotient, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_quotient, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_quotient+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_quotient+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient+1",
                "### 2. Scadere: div_temp_res = Remainder - Divisor ###",
                "movzbl div_divisor, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, div_temp_a",
                "movzbl div_divisor+1, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, div_temp_a+1",
                "### NOT + 1 ###",
                "movzbl div_temp_a, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movl $1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_a",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl div_temp_a+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_a+1",
                "### Final subtraction ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_temp_a, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_temp_a+1, %ebx",
                "movb (%edx, %ebx, 1), %cl",
                "movzbl %al, %ebx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res+1",
                "### Carry Check (Semn) ###",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res+3",
                "movzbl div_temp_res+3, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, is_negative",
                "### 3. MUX Selection (Actualizeaza Remainder si Quotient) ###",
                "movzbl is_negative, %eax",
                "movl SIGN_TO_MASK_LUT(,%eax, 4), %ebx",
                "movl %ebx, div_mask",
                "### Update Quotient bit 0 ###",
                "movzbl div_mask, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movl $1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl div_quotient, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient",
                "### Update Remainder (Select) ###",
                "movzbl div_temp_res, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl div_mask, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_c1",
                "movzbl div_mask, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_c2",
                "movzbl div_remainder, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",

                "### --- ITERATIA 1 --- ###",
                "### 1. Shift Combined ###",
                "movzbl div_quotient+1, %ecx",
                "movb GET_MSB_LUT(%ecx), %al",
                "movb %al, temp_c1",
                "### Remainder = Remainder + Remainder ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_remainder, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_remainder+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder+1",
                "### Adauga bitul extras in Remainder ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_c1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "### Quotient = Quotient << 1 ###",
                "movzbl div_quotient, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_quotient, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_quotient+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_quotient+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient+1",
                "### 2. Scadere: div_temp_res = Remainder - Divisor ###",
                "movzbl div_divisor, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, div_temp_a",
                "movzbl div_divisor+1, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, div_temp_a+1",
                "### NOT + 1 ###",
                "movzbl div_temp_a, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movl $1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_a",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl div_temp_a+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_a+1",
                "### Final subtraction ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_temp_a, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_temp_a+1, %ebx",
                "movb (%edx, %ebx, 1), %cl",
                "movzbl %al, %ebx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res+1",
                "### Carry Check (Semn) ###",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res+3",
                "movzbl div_temp_res+3, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, is_negative",
                "### 3. MUX Selection (Actualizeaza Remainder si Quotient) ###",
                "movzbl is_negative, %eax",
                "movl SIGN_TO_MASK_LUT(,%eax, 4), %ebx",
                "movl %ebx, div_mask",
                "### Update Quotient bit 0 ###",
                "movzbl div_mask, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movl $1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl div_quotient, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient",
                "### Update Remainder (Select) ###",
                "movzbl div_temp_res, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl div_mask, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_c1",
                "movzbl div_mask, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_c2",
                "movzbl div_remainder, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",

                "### --- ITERATIA 0 --- ###",
                "### 1. Shift Combined ###",
                "movzbl div_quotient+1, %ecx",
                "movb GET_MSB_LUT(%ecx), %al",
                "movb %al, temp_c1",
                "### Remainder = Remainder + Remainder ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_remainder, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_remainder+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder+1",
                "### Adauga bitul extras in Remainder ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl temp_c1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",
                "### Quotient = Quotient << 1 ###",
                "movzbl div_quotient, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_quotient, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, current_carry",
                "movzbl div_quotient+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_quotient+1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl %al, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl current_carry, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient+1",
                "### 2. Scadere: div_temp_res = Remainder - Divisor ###",
                "movzbl div_divisor, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, div_temp_a",
                "movzbl div_divisor+1, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, div_temp_a+1",
                "### NOT + 1 ###",
                "movzbl div_temp_a, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movl $1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_a",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl div_temp_a+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_a+1",
                "### Final subtraction ###",
                "movzbl div_remainder, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_temp_a, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl div_remainder+1, %ecx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movzbl div_temp_a+1, %ebx",
                "movb (%edx, %ebx, 1), %cl",
                "movzbl %al, %ebx",
                "movl ADD_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res+1",
                "### Carry Check (Semn) ###",
                "movl ADD_CARRY_PTR(,%ecx, 4), %edx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_temp_res+3",
                "movzbl div_temp_res+3, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, is_negative",
                "### 3. MUX Selection (Actualizeaza Remainder si Quotient) ###",
                "movzbl is_negative, %eax",
                "movl SIGN_TO_MASK_LUT(,%eax, 4), %ebx",
                "movl %ebx, div_mask",
                "### Update Quotient bit 0 ###",
                "movzbl div_mask, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movl $1, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl div_quotient, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_quotient",
                "### Update Remainder (Select) ###",
                "movzbl div_temp_res, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl div_mask, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, temp_c1",
                "movzbl div_mask, %ecx",
                "movb NOT_LUT(%ecx), %al",
                "movb %al, temp_c2",
                "movzbl div_remainder, %ecx",
                "movl AND_PTR(,%ecx, 4), %edx",
                "movzbl temp_c2, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movzbl temp_c1, %ecx",
                "movl OR_PTR(,%ecx, 4), %edx",
                "movzbl %al, %ebx",
                "movb (%edx, %ebx, 1), %al",
                "movb %al, div_remainder",

                "### --- FINALIZARE --- ###",
                "movl temp_ebx, %ebx",
                "movl temp_ecx, %ecx",
                "movl div_quotient, %eax",
                "movl div_remainder, %edx"
            ]
        }
    ]
}
